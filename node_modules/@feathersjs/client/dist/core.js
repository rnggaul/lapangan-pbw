(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["feathers"] = factory();
	else
		root["feathers"] = factory();
})(this, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../commons/lib/debug.js":
/*!*******************************!*\
  !*** ../commons/lib/debug.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.noopDebug = noopDebug;
exports.setDebug = setDebug;
exports.createDebug = createDebug;
var debuggers = {};
function noopDebug() {
  return function () {};
}
var defaultInitializer = noopDebug;
function setDebug(debug) {
  defaultInitializer = debug;
  Object.keys(debuggers).forEach(function (name) {
    debuggers[name] = debug(name);
  });
}
function createDebug(name) {
  if (!debuggers[name]) {
    debuggers[name] = defaultInitializer(name);
  }
  return function () {
    return debuggers[name].apply(debuggers, arguments);
  };
}

/***/ }),

/***/ "../commons/lib/index.js":
/*!*******************************!*\
  !*** ../commons/lib/index.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports._ = void 0;
exports.stripSlashes = stripSlashes;
exports.isPromise = isPromise;
exports.createSymbol = createSymbol;
// Removes all leading and trailing slashes from a path
function stripSlashes(name) {
  return name.replace(/^(\/+)|(\/+)$/g, '');
}
// A set of lodash-y utility functions that use ES6
exports._ = {
  each: function each(obj, callback) {
    if (obj && typeof obj.forEach === 'function') {
      obj.forEach(callback);
    } else if (exports._.isObject(obj)) {
      Object.keys(obj).forEach(function (key) {
        return callback(obj[key], key);
      });
    }
  },
  some: function some(value, callback) {
    return Object.keys(value).map(function (key) {
      return [value[key], key];
    }).some(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        val = _ref2[0],
        key = _ref2[1];
      return callback(val, key);
    });
  },
  every: function every(value, callback) {
    return Object.keys(value).map(function (key) {
      return [value[key], key];
    }).every(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        val = _ref4[0],
        key = _ref4[1];
      return callback(val, key);
    });
  },
  keys: function keys(obj) {
    return Object.keys(obj);
  },
  values: function values(obj) {
    return exports._.keys(obj).map(function (key) {
      return obj[key];
    });
  },
  isMatch: function isMatch(obj, item) {
    return exports._.keys(item).every(function (key) {
      return obj[key] === item[key];
    });
  },
  isEmpty: function isEmpty(obj) {
    return exports._.keys(obj).length === 0;
  },
  isObject: function isObject(item) {
    return _typeof(item) === 'object' && !Array.isArray(item) && item !== null;
  },
  isObjectOrArray: function isObjectOrArray(value) {
    return _typeof(value) === 'object' && value !== null;
  },
  extend: function extend(first) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    return Object.assign.apply(Object, [first].concat(rest));
  },
  omit: function omit(obj) {
    var result = exports._.extend({}, obj);
    for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      keys[_key2 - 1] = arguments[_key2];
    }
    keys.forEach(function (key) {
      return delete result[key];
    });
    return result;
  },
  pick: function pick(source) {
    for (var _len3 = arguments.length, keys = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      keys[_key3 - 1] = arguments[_key3];
    }
    return keys.reduce(function (result, key) {
      if (source[key] !== undefined) {
        result[key] = source[key];
      }
      return result;
    }, {});
  },
  // Recursively merge the source object into the target object
  merge: function merge(target, source) {
    if (exports._.isObject(target) && exports._.isObject(source)) {
      Object.keys(source).forEach(function (key) {
        if (exports._.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, _defineProperty({}, key, {}));
          }
          exports._.merge(target[key], source[key]);
        } else {
          Object.assign(target, _defineProperty({}, key, source[key]));
        }
      });
    }
    return target;
  }
};
// Duck-checks if an object looks like a promise
function isPromise(result) {
  return exports._.isObject(result) && typeof result.then === 'function';
}
function createSymbol(name) {
  return typeof Symbol !== 'undefined' ? Symbol.for(name) : name;
}
__exportStar(__webpack_require__(/*! ./debug */ "../commons/lib/debug.js"), exports);

/***/ }),

/***/ "../feathers/lib/application.js":
/*!**************************************!*\
  !*** ../feathers/lib/application.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Feathers = void 0;
var version_1 = __importDefault(__webpack_require__(/*! ./version */ "../feathers/lib/version.js"));
var events_1 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
var commons_1 = __webpack_require__(/*! @feathersjs/commons */ "../commons/lib/index.js");
var hooks_1 = __webpack_require__(/*! @feathersjs/hooks */ "../../node_modules/@feathersjs/hooks/script/index.js");
var events_2 = __webpack_require__(/*! ./events */ "../feathers/lib/events.js");
var hooks_2 = __webpack_require__(/*! ./hooks */ "../feathers/lib/hooks.js");
var service_1 = __webpack_require__(/*! ./service */ "../feathers/lib/service.js");
var hooks_3 = __webpack_require__(/*! ./hooks */ "../feathers/lib/hooks.js");
var debug = (0, commons_1.createDebug)('@feathersjs/feathers');
var Feathers = /*#__PURE__*/function (_events_1$EventEmitte) {
  function Feathers() {
    var _this;
    _classCallCheck(this, Feathers);
    _this = _callSuper(this, Feathers);
    _this.services = {};
    _this.settings = {};
    _this.mixins = [hooks_2.hookMixin, events_2.eventMixin];
    _this.version = version_1.default;
    _this._isSetup = false;
    _this.registerHooks = (0, hooks_3.enableHooks)(_this);
    _this.registerHooks({
      around: [events_2.eventHook]
    });
    return _this;
  }
  _inherits(Feathers, _events_1$EventEmitte);
  return _createClass(Feathers, [{
    key: "get",
    value: function get(name) {
      return this.settings[name];
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this.settings[name] = value;
      return this;
    }
  }, {
    key: "configure",
    value: function configure(callback) {
      callback.call(this, this);
      return this;
    }
  }, {
    key: "defaultService",
    value: function defaultService(location) {
      throw new Error("Can not find service '".concat(location, "'"));
    }
  }, {
    key: "service",
    value: function service(location) {
      var path = (0, commons_1.stripSlashes)(location) || '/';
      var current = this.services.hasOwnProperty(path) ? this.services[path] : undefined;
      if (typeof current === 'undefined') {
        this.use(path, this.defaultService(path));
        return this.service(path);
      }
      return current;
    }
  }, {
    key: "_setup",
    value: function _setup() {
      var _this2 = this;
      this._isSetup = true;
      return Object.keys(this.services).reduce(function (current, path) {
        return current.then(function () {
          var service = _this2.service(path);
          if (typeof service.setup === 'function') {
            debug("Setting up service for `".concat(path, "`"));
            return service.setup(_this2, path);
          }
        });
      }, Promise.resolve()).then(function () {
        return _this2;
      });
    }
  }, {
    key: "setup",
    get: function get() {
      return this._setup;
    },
    set: function set(value) {
      this._setup = value[hooks_1.HOOKS] ? value : (0, hooks_1.hooks)(value, (0, hooks_1.middleware)().params('server').props({
        app: this
      }));
    }
  }, {
    key: "_teardown",
    value: function _teardown() {
      var _this3 = this;
      this._isSetup = false;
      return Object.keys(this.services).reduce(function (current, path) {
        return current.then(function () {
          var service = _this3.service(path);
          if (typeof service.teardown === 'function') {
            debug("Tearing down service for `".concat(path, "`"));
            return service.teardown(_this3, path);
          }
        });
      }, Promise.resolve()).then(function () {
        return _this3;
      });
    }
  }, {
    key: "teardown",
    get: function get() {
      return this._teardown;
    },
    set: function set(value) {
      this._teardown = value[hooks_1.HOOKS] ? value : (0, hooks_1.hooks)(value, (0, hooks_1.middleware)().params('server').props({
        app: this
      }));
    }
  }, {
    key: "use",
    value: function use(path, service, options) {
      var _this4 = this;
      if (typeof path !== 'string') {
        throw new Error("'".concat(path, "' is not a valid service path."));
      }
      var location = (0, commons_1.stripSlashes)(path) || '/';
      var subApp = service;
      var isSubApp = typeof subApp.service === 'function' && subApp.services;
      if (isSubApp) {
        Object.keys(subApp.services).forEach(function (subPath) {
          return _this4.use("".concat(location, "/").concat(subPath), subApp.service(subPath));
        });
        return this;
      }
      var protoService = (0, service_1.wrapService)(location, service, options);
      var serviceOptions = (0, service_1.getServiceOptions)(protoService);
      var _iterator = _createForOfIteratorHelper(service_1.protectedMethods),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var name = _step.value;
          if (serviceOptions.methods.includes(name)) {
            throw new Error("'".concat(name, "' on service '").concat(location, "' is not allowed as a custom method name"));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      debug("Registering new service at `".concat(location, "`"));
      // Add all the mixins
      this.mixins.forEach(function (fn) {
        return fn.call(_this4, protoService, location, serviceOptions);
      });
      this.services[location] = protoService;
      // If we ran setup already, set this service up explicitly, this will not `await`
      if (this._isSetup && typeof protoService.setup === 'function') {
        debug("Setting up service for `".concat(location, "`"));
        protoService.setup(this, location);
      }
      return this;
    }
  }, {
    key: "unuse",
    value: function () {
      var _unuse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(location) {
        var path, service;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              path = (0, commons_1.stripSlashes)(location) || '/';
              service = this.services[path];
              if (!(service && typeof service.teardown === 'function')) {
                _context.next = 5;
                break;
              }
              _context.next = 5;
              return service.teardown(this, path);
            case 5:
              delete this.services[path];
              return _context.abrupt("return", service);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function unuse(_x) {
        return _unuse.apply(this, arguments);
      }
      return unuse;
    }()
  }, {
    key: "hooks",
    value: function hooks(hookMap) {
      var untypedMap = hookMap;
      if (untypedMap.before || untypedMap.after || untypedMap.error || untypedMap.around) {
        // regular hooks for all service methods
        this.registerHooks(untypedMap);
      } else if (untypedMap.setup || untypedMap.teardown) {
        // .setup and .teardown application hooks
        (0, hooks_1.hooks)(this, untypedMap);
      } else {
        // Other registration formats are just `around` hooks
        this.registerHooks({
          around: untypedMap
        });
      }
      return this;
    }
  }]);
}(events_1.EventEmitter);
exports.Feathers = Feathers;

/***/ }),

/***/ "../feathers/lib/declarations.js":
/*!***************************************!*\
  !*** ../feathers/lib/declarations.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "../feathers/lib/events.js":
/*!*********************************!*\
  !*** ../feathers/lib/events.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.eventHook = eventHook;
exports.eventMixin = eventMixin;
var events_1 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
var service_1 = __webpack_require__(/*! ./service */ "../feathers/lib/service.js");
function eventHook(context, next) {
  var _ref = (0, service_1.getServiceOptions)(context.self),
    events = _ref.events;
  var defaultEvent = service_1.defaultEventMap[context.method] || null;
  context.event = defaultEvent;
  return next().then(function () {
    // Send the event only if the service does not do so already (indicated in the `events` option)
    // This is used for custom events and for client services receiving event from the server
    if (typeof context.event === 'string' && !events.includes(context.event)) {
      var results = Array.isArray(context.result) ? context.result : [context.result];
      results.forEach(function (element) {
        return context.self.emit(context.event, element, context);
      });
    }
  });
}
function eventMixin(service) {
  var isEmitter = typeof service.on === 'function' && typeof service.emit === 'function';
  if (!isEmitter) {
    Object.assign(service, events_1.EventEmitter.prototype);
  }
  return service;
}

/***/ }),

/***/ "../feathers/lib/hooks.js":
/*!********************************!*\
  !*** ../feathers/lib/hooks.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FeathersHookManager = void 0;
exports.convertHookData = convertHookData;
exports.collectHooks = collectHooks;
exports.enableHooks = enableHooks;
exports.createContext = createContext;
exports.hookMixin = hookMixin;
var hooks_1 = __webpack_require__(/*! @feathersjs/hooks */ "../../node_modules/@feathersjs/hooks/script/index.js");
var service_1 = __webpack_require__(/*! ./service */ "../feathers/lib/service.js");
var types = ['before', 'after', 'error', 'around'];
var isType = function isType(value) {
  return types.includes(value);
};
// Converts different hook registration formats into the
// same internal format
function convertHookData(input) {
  var result = {};
  if (Array.isArray(input)) {
    result.all = input;
  } else if (_typeof(input) !== 'object') {
    result.all = [input];
  } else {
    for (var _i = 0, _Object$keys = Object.keys(input); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var value = input[key];
      result[key] = Array.isArray(value) ? value : [value];
    }
  }
  return result;
}
function collectHooks(target, method) {
  var _target$__hooks = target.__hooks,
    collected = _target$__hooks.collected,
    collectedAll = _target$__hooks.collectedAll,
    around = _target$__hooks.around;
  return [].concat(_toConsumableArray(around.all || []), _toConsumableArray(around[method] || []), _toConsumableArray(collectedAll.before || []), _toConsumableArray(collected[method] || []), _toConsumableArray(collectedAll.after || []));
}
// Add `.hooks` functionality to an object
function enableHooks(object) {
  var store = {
    around: {},
    before: {},
    after: {},
    error: {},
    collected: {},
    collectedAll: {}
  };
  Object.defineProperty(object, '__hooks', {
    configurable: true,
    value: store,
    writable: true
  });
  return function registerHooks(input) {
    var store = this.__hooks;
    var map = Object.keys(input).reduce(function (map, type) {
      if (!isType(type)) {
        throw new Error("'".concat(type, "' is not a valid hook type"));
      }
      map[type] = convertHookData(input[type]);
      return map;
    }, {});
    var types = Object.keys(map);
    types.forEach(function (type) {
      return Object.keys(map[type]).forEach(function (method) {
        var _a;
        var mapHooks = map[type][method];
        var storeHooks = (_a = store[type])[method] || (_a[method] = []);
        storeHooks.push.apply(storeHooks, _toConsumableArray(mapHooks));
        if (method === 'all') {
          if (store.before[method] || store.error[method]) {
            var beforeAll = (0, hooks_1.collect)({
              before: store.before[method] || [],
              error: store.error[method] || []
            });
            store.collectedAll.before = [beforeAll];
          }
          if (store.after[method]) {
            var afterAll = (0, hooks_1.collect)({
              after: store.after[method] || []
            });
            store.collectedAll.after = [afterAll];
          }
        } else {
          if (store.before[method] || store.after[method] || store.error[method]) {
            var collected = (0, hooks_1.collect)({
              before: store.before[method] || [],
              after: store.after[method] || [],
              error: store.error[method] || []
            });
            store.collected[method] = [collected];
          }
        }
      });
    });
    return this;
  };
}
function createContext(service, method) {
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var createContext = service[method].createContext;
  if (typeof createContext !== 'function') {
    throw new Error("Can not create context for method ".concat(method));
  }
  return createContext(data);
}
var FeathersHookManager = /*#__PURE__*/function (_hooks_1$HookManager) {
  function FeathersHookManager(app, method) {
    var _this;
    _classCallCheck(this, FeathersHookManager);
    _this = _callSuper(this, FeathersHookManager);
    _this.app = app;
    _this.method = method;
    _this._middleware = [];
    return _this;
  }
  _inherits(FeathersHookManager, _hooks_1$HookManager);
  return _createClass(FeathersHookManager, [{
    key: "collectMiddleware",
    value: function collectMiddleware(self, args) {
      var appHooks = collectHooks(this.app, this.method);
      var middleware = _superPropGet(FeathersHookManager, "collectMiddleware", this, 3)([self, args]);
      var methodHooks = collectHooks(self, this.method);
      return [].concat(_toConsumableArray(appHooks), _toConsumableArray(middleware), _toConsumableArray(methodHooks));
    }
  }, {
    key: "initializeContext",
    value: function initializeContext(self, args, context) {
      var ctx = _superPropGet(FeathersHookManager, "initializeContext", this, 3)([self, args, context]);
      ctx.params = ctx.params || {};
      return ctx;
    }
  }, {
    key: "middleware",
    value: function middleware(mw) {
      var _this$_middleware;
      (_this$_middleware = this._middleware).push.apply(_this$_middleware, _toConsumableArray(mw));
      return this;
    }
  }]);
}(hooks_1.HookManager);
exports.FeathersHookManager = FeathersHookManager;
function hookMixin(service, path, options) {
  var _this2 = this;
  if (typeof service.hooks === 'function') {
    return service;
  }
  var hookMethods = (0, service_1.getHookMethods)(service, options);
  var serviceMethodHooks = hookMethods.reduce(function (res, method) {
    var _FeathersHookManager;
    var params = service_1.defaultServiceArguments[method] || ['data', 'params'];
    res[method] = (_FeathersHookManager = new FeathersHookManager(_this2, method)).params.apply(_FeathersHookManager, _toConsumableArray(params)).props({
      app: _this2,
      path: path,
      method: method,
      service: service,
      event: null,
      type: 'around',
      get statusCode() {
        var _a;
        return (_a = this.http) === null || _a === void 0 ? void 0 : _a.status;
      },
      set statusCode(value) {
        this.http = this.http || {};
        this.http.status = value;
      }
    });
    return res;
  }, {});
  var registerHooks = enableHooks(service);
  (0, hooks_1.hooks)(service, serviceMethodHooks);
  service.hooks = function (hookOptions) {
    var _this3 = this;
    if (hookOptions.before || hookOptions.after || hookOptions.error || hookOptions.around) {
      return registerHooks.call(this, hookOptions);
    }
    if (Array.isArray(hookOptions)) {
      return (0, hooks_1.hooks)(this, hookOptions);
    }
    Object.keys(hookOptions).forEach(function (method) {
      var manager = (0, hooks_1.getManager)(_this3[method]);
      if (!(manager instanceof FeathersHookManager)) {
        throw new Error("Method ".concat(method, " is not a Feathers hooks enabled service method"));
      }
      manager.middleware(hookOptions[method]);
    });
    return this;
  };
  return service;
}

/***/ }),

/***/ "../feathers/lib/index.js":
/*!********************************!*\
  !*** ../feathers/lib/index.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {



var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Feathers = exports.version = void 0;
exports.feathers = feathers;
var commons_1 = __webpack_require__(/*! @feathersjs/commons */ "../commons/lib/index.js");
var version_1 = __importDefault(__webpack_require__(/*! ./version */ "../feathers/lib/version.js"));
exports.version = version_1.default;
var application_1 = __webpack_require__(/*! ./application */ "../feathers/lib/application.js");
Object.defineProperty(exports, "Feathers", ({
  enumerable: true,
  get: function get() {
    return application_1.Feathers;
  }
}));
function feathers() {
  return new application_1.Feathers();
}
feathers.setDebug = commons_1.setDebug;
__exportStar(__webpack_require__(/*! ./hooks */ "../feathers/lib/hooks.js"), exports);
__exportStar(__webpack_require__(/*! ./declarations */ "../feathers/lib/declarations.js"), exports);
__exportStar(__webpack_require__(/*! ./service */ "../feathers/lib/service.js"), exports);
if (true) {
  module.exports = Object.assign(feathers, module.exports);
}

/***/ }),

/***/ "../feathers/lib/service.js":
/*!**********************************!*\
  !*** ../feathers/lib/service.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeServiceOptions = exports.protectedMethods = exports.defaultServiceEvents = exports.defaultEventMap = exports.defaultServiceMethods = exports.defaultServiceArguments = exports.SERVICE = void 0;
exports.getHookMethods = getHookMethods;
exports.getServiceOptions = getServiceOptions;
exports.wrapService = wrapService;
var events_1 = __webpack_require__(/*! events */ "../../node_modules/events/events.js");
var commons_1 = __webpack_require__(/*! @feathersjs/commons */ "../commons/lib/index.js");
exports.SERVICE = (0, commons_1.createSymbol)('@feathersjs/service');
exports.defaultServiceArguments = {
  find: ['params'],
  get: ['id', 'params'],
  create: ['data', 'params'],
  update: ['id', 'data', 'params'],
  patch: ['id', 'data', 'params'],
  remove: ['id', 'params']
};
exports.defaultServiceMethods = ['find', 'get', 'create', 'update', 'patch', 'remove'];
exports.defaultEventMap = {
  create: 'created',
  update: 'updated',
  patch: 'patched',
  remove: 'removed'
};
exports.defaultServiceEvents = Object.values(exports.defaultEventMap);
exports.protectedMethods = Object.keys(Object.prototype).concat(Object.keys(events_1.EventEmitter.prototype)).concat(['all', 'around', 'before', 'after', 'error', 'hooks', 'setup', 'teardown', 'publish']);
function getHookMethods(service, options) {
  var methods = options.methods;
  return exports.defaultServiceMethods.filter(function (m) {
    return typeof service[m] === 'function' && !methods.includes(m);
  }).concat(methods);
}
function getServiceOptions(service) {
  return service[exports.SERVICE];
}
var normalizeServiceOptions = function normalizeServiceOptions(service) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$methods = options.methods,
    methods = _options$methods === void 0 ? exports.defaultServiceMethods.filter(function (method) {
      return typeof service[method] === 'function';
    }) : _options$methods,
    _options$events = options.events,
    events = _options$events === void 0 ? service.events || [] : _options$events;
  var serviceEvents = options.serviceEvents || exports.defaultServiceEvents.concat(events);
  return _objectSpread(_objectSpread({}, options), {}, {
    events: events,
    methods: methods,
    serviceEvents: serviceEvents
  });
};
exports.normalizeServiceOptions = normalizeServiceOptions;
function wrapService(location, service, options) {
  // Do nothing if this is already an initialized
  if (service[exports.SERVICE]) {
    return service;
  }
  var protoService = Object.create(service);
  var serviceOptions = (0, exports.normalizeServiceOptions)(service, options);
  if (Object.keys(serviceOptions.methods).length === 0 && ![].concat(_toConsumableArray(exports.defaultServiceMethods), ['setup', 'teardown']).some(function (method) {
    return typeof service[method] === 'function';
  })) {
    throw new Error("Invalid service object passed for path `".concat(location, "`"));
  }
  Object.defineProperty(protoService, exports.SERVICE, {
    value: serviceOptions
  });
  return protoService;
}

/***/ }),

/***/ "../feathers/lib/version.js":
/*!**********************************!*\
  !*** ../feathers/lib/version.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = 'development';

/***/ }),

/***/ "../../node_modules/events/events.js":
/*!*******************************************!*\
  !*** ../../node_modules/events/events.js ***!
  \*******************************************/
/***/ (function(module) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./src/core.ts":
/*!*********************!*\
  !*** ./src/core.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! @feathersjs/feathers */ "../feathers/lib/index.js"), exports);


/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/base.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/base.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setMiddleware = exports.getMiddleware = exports.setManager = exports.getManager = exports.convertOptions = exports.HookManager = exports.BaseHookContext = exports.HOOKS = void 0;
var utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@feathersjs/hooks/script/utils.js");
exports.HOOKS = Symbol.for('@feathersjs/hooks');
/**
 * The base hook context.
 */
var BaseHookContext = /*#__PURE__*/function () {
  function BaseHookContext() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, BaseHookContext);
    Object.defineProperty(this, "self", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.assign(this, data);
  }
  return _createClass(BaseHookContext, [{
    key: "toJSON",
    value: function toJSON() {
      var _this = this;
      var keys = Object.keys(this);
      var proto = Object.getPrototypeOf(this);
      while (proto) {
        keys.push.apply(keys, _toConsumableArray(Object.keys(proto)));
        proto = Object.getPrototypeOf(proto);
      }
      return keys.reduce(function (result, key) {
        result[key] = _this[key];
        return result;
      }, {});
    }
  }]);
}();
exports.BaseHookContext = BaseHookContext;
var HookManager = /*#__PURE__*/function () {
  function HookManager() {
    _classCallCheck(this, HookManager);
    Object.defineProperty(this, "_parent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "_params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "_middleware", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "_props", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "_defaults", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  return _createClass(HookManager, [{
    key: "parent",
    value: function parent(_parent) {
      this._parent = _parent;
      return this;
    }
  }, {
    key: "middleware",
    value: function middleware(_middleware) {
      this._middleware = _middleware !== null && _middleware !== void 0 && _middleware.length ? _middleware : null;
      return this;
    }
  }, {
    key: "getMiddleware",
    value: function getMiddleware() {
      var _this$_parent;
      var previous = (_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent.getMiddleware();
      if (previous && this._middleware) {
        return previous.concat(this._middleware);
      }
      return previous || this._middleware;
    }
  }, {
    key: "collectMiddleware",
    value: function collectMiddleware(self, _args) {
      var otherMiddleware = getMiddleware(self);
      var middleware = this.getMiddleware();
      if (otherMiddleware && middleware) {
        return otherMiddleware.concat(middleware);
      }
      return otherMiddleware || middleware || [];
    }
  }, {
    key: "props",
    value: function props(_props) {
      if (!this._props) {
        this._props = {};
      }
      (0, utils_js_1.copyProperties)(this._props, _props);
      return this;
    }
  }, {
    key: "getProps",
    value: function getProps() {
      var _this$_parent2;
      var previous = (_this$_parent2 = this._parent) === null || _this$_parent2 === void 0 ? void 0 : _this$_parent2.getProps();
      if (previous && this._props) {
        return (0, utils_js_1.copyProperties)({}, previous, this._props);
      }
      return previous || this._props || null;
    }
  }, {
    key: "params",
    value: function params() {
      for (var _len = arguments.length, _params = new Array(_len), _key = 0; _key < _len; _key++) {
        _params[_key] = arguments[_key];
      }
      this._params = _params;
      return this;
    }
  }, {
    key: "getParams",
    value: function getParams() {
      var _this$_parent3;
      var previous = (_this$_parent3 = this._parent) === null || _this$_parent3 === void 0 ? void 0 : _this$_parent3.getParams();
      if (previous && this._params) {
        return previous.concat(this._params);
      }
      return previous || this._params;
    }
  }, {
    key: "defaults",
    value: function defaults(_defaults) {
      this._defaults = _defaults;
      return this;
    }
  }, {
    key: "getDefaults",
    value: function getDefaults(self, args, context) {
      var _this$_parent4;
      var defaults = typeof this._defaults === 'function' ? this._defaults(self, args, context) : null;
      var previous = (_this$_parent4 = this._parent) === null || _this$_parent4 === void 0 ? void 0 : _this$_parent4.getDefaults(self, args, context);
      if (previous && defaults) {
        return Object.assign({}, previous, defaults);
      }
      return previous || defaults;
    }
  }, {
    key: "getContextClass",
    value: function getContextClass() {
      var Base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BaseHookContext;
      var ContextClass = /*#__PURE__*/function (_Base) {
        function ContextClass(data) {
          _classCallCheck(this, ContextClass);
          return _callSuper(this, ContextClass, [data]);
        }
        _inherits(ContextClass, _Base);
        return _createClass(ContextClass);
      }(Base);
      var params = this.getParams();
      var props = this.getProps();
      if (params) {
        params.forEach(function (name, index) {
          if ((props === null || props === void 0 ? void 0 : props[name]) !== undefined) {
            throw new Error("Hooks can not have a property and param named '".concat(name, "'. Use .defaults instead."));
          }
          Object.defineProperty(ContextClass.prototype, name, {
            enumerable: true,
            get: function get() {
              return this === null || this === void 0 ? void 0 : this.arguments[index];
            },
            set: function set(value) {
              this.arguments[index] = value;
            }
          });
        });
      }
      if (props) {
        (0, utils_js_1.copyProperties)(ContextClass.prototype, props);
      }
      return ContextClass;
    }
  }, {
    key: "initializeContext",
    value: function initializeContext(self, args, context) {
      var ctx = this._parent ? this._parent.initializeContext(self, args, context) : context;
      var defaults = this.getDefaults(self, args, ctx);
      if (self) {
        ctx.self = self;
      }
      ctx.arguments = args;
      if (defaults) {
        for (var _i = 0, _Object$keys = Object.keys(defaults); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          if (ctx[name] === undefined) {
            ctx[name] = defaults[name];
          }
        }
      }
      return ctx;
    }
  }]);
}();
exports.HookManager = HookManager;
function convertOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  if (!options) {
    return new HookManager();
  }
  return Array.isArray(options) ? new HookManager().middleware(options) : options;
}
exports.convertOptions = convertOptions;
function getManager(target) {
  return target && target[exports.HOOKS] || null;
}
exports.getManager = getManager;
function setManager(target, manager) {
  var parent = getManager(target);
  target[exports.HOOKS] = manager.parent(parent);
  return target;
}
exports.setManager = setManager;
function getMiddleware(target) {
  var manager = getManager(target);
  return manager ? manager.getMiddleware() : null;
}
exports.getMiddleware = getMiddleware;
function setMiddleware(target, middleware) {
  var manager = new HookManager().middleware(middleware);
  return setManager(target, manager);
}
exports.setMiddleware = setMiddleware;

/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/compose.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/compose.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {



function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compose = void 0;
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }
  var _iterator = _createForOfIteratorHelper(middleware),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var fn = _step.value;
      if (typeof fn !== 'function') {
        throw new TypeError('Middleware must be composed of functions!');
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return function (context, next) {
    // last called middleware #
    var index = -1;
    return dispatch.call(this, 0);
    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }
      index = i;
      var fn = middleware[i];
      if (i === middleware.length) {
        fn = next;
      }
      if (!fn) {
        return Promise.resolve();
      }
      try {
        return Promise.resolve(fn.call(this, context, dispatch.bind(this, i + 1)));
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}
exports.compose = compose;

/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/hooks.js":
/*!************************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/hooks.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.legacyDecorator = exports.hookDecorator = exports.objectHooks = exports.functionHooks = exports.getOriginal = void 0;
var compose_js_1 = __webpack_require__(/*! ./compose.js */ "../../node_modules/@feathersjs/hooks/script/compose.js");
var base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/@feathersjs/hooks/script/base.js");
var utils_js_1 = __webpack_require__(/*! ./utils.js */ "../../node_modules/@feathersjs/hooks/script/utils.js");
function getOriginal(fn) {
  return typeof fn.original === 'function' ? getOriginal(fn.original) : fn;
}
exports.getOriginal = getOriginal;
function functionHooks(fn, managerOrMiddleware) {
  if (typeof fn !== 'function') {
    throw new Error('Can not apply hooks to non-function');
  }
  var manager = (0, base_js_1.convertOptions)(managerOrMiddleware);
  var _wrapper = function wrapper() {
    var _this = this;
    var Context = _wrapper.Context,
      original = _wrapper.original;
    // If we got passed an existing HookContext instance, we want to return it as well
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var returnContext = args[args.length - 1] instanceof Context;
    // Use existing context or default
    var base = returnContext ? args.pop() : new Context();
    // Initialize the context
    var context = manager.initializeContext(this, args, base);
    // Assemble the hook chain
    var hookChain = [
    // Return `ctx.result` or the context
    function (ctx, next) {
      return next().then(function () {
        return returnContext ? ctx : ctx.result;
      });
    }];
    // Create the hook chain by calling the `collectMiddleware function
    var mw = manager.collectMiddleware(this, args);
    if (mw) {
      Array.prototype.push.apply(hookChain, mw);
    }
    // Runs the actual original method if `ctx.result` is not already set
    hookChain.push(function (ctx, next) {
      if (!Object.prototype.hasOwnProperty.call(context, 'result')) {
        return Promise.resolve(original.apply(_this, ctx.arguments)).then(function (result) {
          ctx.result = result;
          return next();
        });
      }
      return next();
    });
    return (0, compose_js_1.compose)(hookChain).call(this, context);
  };
  (0, utils_js_1.copyFnProperties)(_wrapper, fn);
  (0, utils_js_1.copyProperties)(_wrapper, fn);
  (0, base_js_1.setManager)(_wrapper, manager);
  return Object.assign(_wrapper, {
    original: getOriginal(fn),
    Context: manager.getContextClass(),
    createContext: function createContext() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new _wrapper.Context(data);
    }
  });
}
exports.functionHooks = functionHooks;
function objectHooks(obj, hooks) {
  if (Array.isArray(hooks)) {
    return (0, base_js_1.setMiddleware)(obj, hooks);
  }
  for (var _i = 0, _Object$keys = Object.keys(hooks); _i < _Object$keys.length; _i++) {
    var method = _Object$keys[_i];
    var target = typeof obj[method] === 'function' ? obj : obj.prototype;
    var fn = target && target[method];
    if (typeof fn !== 'function') {
      throw new Error("Can not apply hooks. '".concat(method, "' is not a function"));
    }
    var manager = (0, base_js_1.convertOptions)(hooks[method]);
    target[method] = functionHooks(fn, manager.props({
      method: method
    }));
  }
  return obj;
}
exports.objectHooks = objectHooks;
var hookDecorator = function hookDecorator(managerOrMiddleware) {
  return function (target, context) {
    var manager = (0, base_js_1.convertOptions)(managerOrMiddleware);
    if (context.kind === 'class') {
      (0, base_js_1.setManager)(target.prototype, manager);
      return target;
    } else if (context.kind === 'method') {
      var method = String(context.name);
      return functionHooks(target, manager.props({
        method: method
      }));
    }
    throw new Error('Can not apply hooks.');
  };
};
exports.hookDecorator = hookDecorator;
var legacyDecorator = function legacyDecorator(managerOrMiddleware) {
  var wrapper = function wrapper(_target, method, descriptor) {
    var manager = (0, base_js_1.convertOptions)(managerOrMiddleware);
    if (!descriptor) {
      (0, base_js_1.setManager)(_target.prototype, manager);
      return _target;
    }
    var fn = descriptor.value;
    if (typeof fn !== 'function') {
      throw new Error("Can not apply hooks. '".concat(method, "' is not a function"));
    }
    descriptor.value = functionHooks(fn, manager.props({
      method: method
    }));
    return descriptor;
  };
  return wrapper;
};
exports.legacyDecorator = legacyDecorator;

/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hooks = exports.middleware = void 0;
var base_js_1 = __webpack_require__(/*! ./base.js */ "../../node_modules/@feathersjs/hooks/script/base.js");
var hooks_js_1 = __webpack_require__(/*! ./hooks.js */ "../../node_modules/@feathersjs/hooks/script/hooks.js");
__exportStar(__webpack_require__(/*! ./hooks.js */ "../../node_modules/@feathersjs/hooks/script/hooks.js"), exports);
__exportStar(__webpack_require__(/*! ./compose.js */ "../../node_modules/@feathersjs/hooks/script/compose.js"), exports);
__exportStar(__webpack_require__(/*! ./base.js */ "../../node_modules/@feathersjs/hooks/script/base.js"), exports);
__exportStar(__webpack_require__(/*! ./regular.js */ "../../node_modules/@feathersjs/hooks/script/regular.js"), exports);
/**
 * Initializes a hook settings object with the given middleware.
 * @param mw The list of middleware
 * @param options Middleware options (params, default, props)
 */
function middleware(mw, options) {
  var manager = new base_js_1.HookManager().middleware(mw);
  if (options) {
    if (options.params) {
      manager.params.apply(manager, _toConsumableArray(options.params));
    }
    if (options.defaults) {
      manager.defaults(options.defaults);
    }
    if (options.props) {
      manager.props(options.props);
    }
  }
  return manager;
}
exports.middleware = middleware;
// Fallthrough to actual implementation
function hooks() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var target = args[0],
    _hooks = args[1];
  if (typeof target === 'function' && (_hooks instanceof base_js_1.HookManager || Array.isArray(_hooks) || args.length === 1)) {
    return (0, hooks_js_1.functionHooks)(target, _hooks);
  }
  if (args.length === 2) {
    return (0, hooks_js_1.objectHooks)(target, _hooks);
  }
  return (0, hooks_js_1.hookDecorator)(target);
}
exports.hooks = hooks;

/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/regular.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/regular.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.collect = exports.fromErrorHook = exports.fromAfterHook = exports.fromBeforeHook = exports.runHooks = exports.runHook = void 0;
var compose_js_1 = __webpack_require__(/*! ./compose.js */ "../../node_modules/@feathersjs/hooks/script/compose.js");
var runHook = function runHook(hook, context, type) {
  var typeBefore = context.type;
  if (type) context.type = type;
  return Promise.resolve(hook.call(context.self, context)).then(function (res) {
    if (type) context.type = typeBefore;
    if (res && res !== context) {
      Object.assign(context, res);
    }
  });
};
exports.runHook = runHook;
var runHooks = function runHooks(hooks) {
  return function (context) {
    return hooks.reduce(function (promise, hook) {
      return promise.then(function () {
        return (0, exports.runHook)(hook, context);
      });
    }, Promise.resolve(context));
  };
};
exports.runHooks = runHooks;
function fromBeforeHook(hook) {
  return function (context, next) {
    return (0, exports.runHook)(hook, context, 'before').then(next);
  };
}
exports.fromBeforeHook = fromBeforeHook;
function fromAfterHook(hook) {
  return function (context, next) {
    return next().then(function () {
      return (0, exports.runHook)(hook, context, 'after');
    });
  };
}
exports.fromAfterHook = fromAfterHook;
function fromErrorHook(hook) {
  return function (context, next) {
    return next().catch(function (error) {
      if (context.error !== error || context.result !== undefined) {
        context.original = _objectSpread({}, context);
        context.error = error;
        delete context.result;
      }
      return (0, exports.runHook)(hook, context, 'error').then(function () {
        if (context.result === undefined && context.error !== undefined) {
          throw context.error;
        }
      }).catch(function (error) {
        context.error = error;
        throw context.error;
      });
    });
  };
}
exports.fromErrorHook = fromErrorHook;
function collect(_ref) {
  var _ref$before = _ref.before,
    before = _ref$before === void 0 ? [] : _ref$before,
    _ref$after = _ref.after,
    after = _ref$after === void 0 ? [] : _ref$after,
    _ref$error = _ref.error,
    error = _ref$error === void 0 ? [] : _ref$error;
  var beforeHooks = before.map(fromBeforeHook);
  var afterHooks = _toConsumableArray(after).reverse().map(fromAfterHook);
  var errorHooks = error.length ? [fromErrorHook((0, exports.runHooks)(error))] : [];
  return (0, compose_js_1.compose)([].concat(errorHooks, _toConsumableArray(beforeHooks), _toConsumableArray(afterHooks)));
}
exports.collect = collect;

/***/ }),

/***/ "../../node_modules/@feathersjs/hooks/script/utils.js":
/*!************************************************************!*\
  !*** ../../node_modules/@feathersjs/hooks/script/utils.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {



function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.copyFnProperties = exports.copyProperties = void 0;
function copyProperties(target) {
  for (var _len = arguments.length, originals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    originals[_key - 1] = arguments[_key];
  }
  for (var _i = 0, _originals = originals; _i < _originals.length; _i++) {
    var original = _originals[_i];
    var originalProps = Object.keys(original).concat(Object.getOwnPropertySymbols(original));
    var _iterator = _createForOfIteratorHelper(originalProps),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prop = _step.value;
        var propDescriptor = Object.getOwnPropertyDescriptor(original, prop);
        if (propDescriptor && !Object.prototype.hasOwnProperty.call(target, prop)) {
          Object.defineProperty(target, prop, propDescriptor);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return target;
}
exports.copyProperties = copyProperties;
function copyFnProperties(target, original) {
  var internalProps = ['name', 'length'];
  try {
    for (var _i2 = 0, _internalProps = internalProps; _i2 < _internalProps.length; _i2++) {
      var prop = _internalProps[_i2];
      var value = original[prop];
      Object.defineProperty(target, prop, {
        value: value
      });
    }
  } catch (_e) {
    // Avoid IE error
  }
  return target;
}
exports.copyFnProperties = copyFnProperties;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=core.js.map